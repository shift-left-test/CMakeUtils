from __future__ import print_function
import os
import subprocess
import tempfile
import shutil
import unittest
import json


class Output(object):
    """The console output holder class.

    This class provides various output comparison helper functions.
    """

    def __init__(self, output):
        """Default constructor

        Args:
          output (str): a console output string
        """
        self.output = output

    def empty(self):
        """Assert that the output is empty

        Returns:
          True if the output is empty, False otherwise
        """
        return not self.output.strip()

    def contains(self, text):
        """Assert that the output contains the given text

        Args:
          text (str): text to examine

        Returns:
          True if the output contains the text, False otherwise
        """
        return text in self.output

    def __str__(self):
        """Print the console output string
        """
        return self.output

class Outputs(object):
    def __init__(self):
        self.outputs = {}

    def __getitem__(self, key):
        return self.outputs[key]

    def __setitem__(self, key, value):
        self.outputs[key] = value

    def empty(self):
        return all(output.empty() for output in self.outputs.values())

    def emptyOf(self, *keys):
        filtered = []
        for key, value in self.outputs.items():
            if key in keys:
                filtered.append(value)
        return all(output.empty() for output in filtered)

    def __str__(self):
        items = self.outputs.items()
        return ", ".join("'{0}'='{1}'".format(key, value) for (key, value) in items)

class Phase(object):
    """The phase class to distinguish between the configuration stage (cmake)
    and the actual build stage (make).

    This class holds the stdout and stderr of the each stage.
    """

    def __init__(self, outputs):
        """Default constructor

        Args:
          outputs (tuple): stderr and stdout
        """
        self.stdout = Output(outputs[0])
        self.stderr = Output(outputs[1])

class CompileCommands(object):
    """This class holds the information of compilation commands
    """
    def __init__(self, filename):
        try:
            self.commands = json.load(open(filename, "r"))
        except:
            self.commands = []

    def commandOf(self, filename):
        """Return the relevant compile command of the given file
        """
        for command in self.commands:
            if command["file"].endswith(filename):
                return command["command"]
        return ""

class BuildResult(object):
    """This class contains the overall build result of the cmake and provides
    various helper functions to examine the build result generated by a given
    cmake script.
    """

    def __init__(self, tempDir, cmake, make, test):
        """Default constructor

        Args:
          tempDir (file): path to a temporary directory
          cmake (Phase): cmake stdout and stderr
          make (Phase): make stdout and stderr
          test (Phase): test stdout and stderr
        """
        self.tempDir = tempDir

        self.stdout = Outputs()
        self.stdout["cmake"] = cmake.stdout
        self.stdout["make"] = make.stdout
        self.stdout["test"] = test.stdout

        self.stderr = Outputs()
        self.stderr["cmake"] = cmake.stderr
        self.stderr["make"] = make.stderr
        self.stderr["test"] = test.stderr

        self.compile = CompileCommands(self.resolve("compile_commands.json"))

    def files(self):
        """List of the files within the build directory
        """
        fileSet = []
        for root, _, files in os.walk(self.tempDir):
            for f in files:
                fileSet.append(os.path.join(root[len(self.tempDir):], f))
        return fileSet

    def resolve(self, path):
        """Resolve a relative path against the build directory
        """
        return os.path.join(self.tempDir, path)

    def exists(self, filename):
        """Test if the given file exists in the build directory
        """
        return os.path.exists(self.resolve(filename))


class CMakeTestUtil(object):
    """A CMake helper class for testing purpose
    """
    def __init__(self):
        """Default constructor
        """
        self.tempDirs = []

    def __del__(self):
        """Default destructor

        This is intended to delete the temporal build directories
        """
        for tempDir in self.tempDirs:
            try:
                if os.path.exists(tempDir):
                    shutil.rmtree(tempDir)
            except OSError as e:
                print(e)

    def runCMake(self, sourceDir):
        """Execute a CMakeLists.txt under the given source directory and
        return the result as an instance of BuildResult

        Args:
          sourceDir (str): path to a directory which contains a CMakeLists.txt

        Returns:
          BuildResult instance
        """
        def execute(command):
            proc = subprocess.Popen(command, shell = True,
                                    stdout = subprocess.PIPE,
                                    stderr = subprocess.PIPE)
            return Phase(proc.communicate())

        tempDir = tempfile.mkdtemp(suffix=".test", prefix="cmake_")
        self.tempDirs.append(tempDir)

        cmakeDir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "scripts")

        return BuildResult(tempDir,
                           execute("cmake -S{0} -B{1} -DCMAKE_MODULE_PATH={2}".format(sourceDir, tempDir, cmakeDir)),
                           execute("make -C {0}".format(tempDir)),
                           execute("make test -C {0}".format(tempDir)))


class TestCase(unittest.TestCase):
    """CMake test helper class

    This class works as a foundation of the CMake test cases.
    """
    def setUp(self):
        self.util = CMakeTestUtil()

    def tearDown(self):
        del self.util

    def runCMake(self, sourceDir):
        return self.util.runCMake(sourceDir)
